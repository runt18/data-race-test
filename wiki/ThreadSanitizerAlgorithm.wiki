#summary Data race detection algorithm used by ThreadSanitizer.

*UNDER CONSTRUCTION!*

<wiki:toc max_depth="1" />

=Definitions=

*Tid* (thread id): a unique number identifying a thread of the running program.

*Addr* (address):  a pointer to the memory of the running program (a 64-bit number on a 64-bit system).

*Event-Type*: one of  `Read`, `Write` (memory access events),
`Wrlock`, `Rdlock`, `Wrunlock`, `Rdunlock` (locking events),
`Signal`, `Wait` (happens-before events).

*Event*: a triple `{Event-Type, Tid, Addr}`. 
We will write `Event-Type(Tid,Addr)` or `Event-Type(Addr)` if `Tid` is obvious from the context.

*Lock*: an  address that appeared in a locking event. <BR>
A lock `L` is *wr-held* by a thread `T` at a given point of time if the number of events
`Wrlock(T,L)` observed so far is greater than the number of events `Wrunlock(T,L)`. <BR>
A lock `L` is *rd-held* by thread `T` if it is wr-held by `T` or if the
number of events `Rdlock(T,L)` is greter than the number of events `Rdunlock(T,L)`.

*Lock Set*: (`LS`) a set of locks. <BR>
*Writer Lock Set* (`LSwr`): the set of all wr-held locks of a given thread. <BR>
*Reader Lock Set* (`LSrd`): the set of all rd-held locks of a given thread. <BR>
*Event Lock Set*:  `LSwr` for a `Write` event and `LSrd` for a `Read` event.


*Happens-before arc*: a pair of events `X=Signal(Tx,Ax)` and `Y=Wait(Ty,Ay)` such that   `Ax = Ay`, `Tx != Ty` and `X` is observed first.



*Happens-before*: a partial order on the set of events. <BR>
Given two events `X=TypeX(Tx,Ax)` and `Y=TypeY(Ty,Ay)` 
the event `X` *happens-before* or *preceedes* the event `Y` (in short, `X < Y`) if `X` has been observed before `Y` and at least on of the following statements is true:
  * `Tx = Ty`
  * `{X,Y}` is a happens-before arc.
  * There exist two events `E1` and `E2`, such that `X <= E1 < E2 <= Y` (i.e. happens-before is transitive).

*Context of event*: information that allows the users to understand where the given event has appeared. Usually, the context is a stack trace (TODO).

*Segment*: a sequence of events of one thread that contains no
synchronization events. The context of a segment is the context of the
first event in the segment. Each segment has it's writer and reader Lock Sets.

http://data-race-test.googlecode.com/svn/trunk/msm/exa3.png

The figure above shows three different threads divided into segments.
  * `S1 < S4` because these segments are in the same thread.
  * `S1 < S5` due to happens-before arc created by `Signal(T1,H1)` and `Wait(T2,H2)`.
  * `S1 < S7` because happens-before is transitive.
  * `!(S4 < S2)` (`S4` does not happen-before `S2`) 


*Segment Set*: a set of segments such that none of the segments in the set happens-before another segment.

*Concurrent*: two memory access events are *concurrent* if non of them happens-before another one and the intresection of the lock sets of these events is empty.

*Data Race*: a situation where there are two concurrent memory access events
with the same address and at least one of the events is `Write`.


=State machine=
The state of ThreadSanitizer consists of global and per-byte states.
Global state is the information about synchronization events that were observed
so far (lock sets, happens-before arcs). Per-byte state (also called
Shadow memory or metadata) is the information about each address (one byte of memory) of the running program. It consists of two segment sets: writer
segment set `SSwr` and reader segment set `SSrd`.
`SSwr` of a given address is a set of segments where the writes to this address
appeared. `SSrd` is a set of all segments where the reads from the given
address appeared, such that for every segment `Sr` in `SSrd` and segment `Sw` in `SSwr`, 
`Sr` does not happen-before `Sw`.

The state machine updates the state on each event and reports a
possible data race if needed.

{{{
def HandleReadOrWriteEvent(is_write, tid, addr):
  (SSwr, SSrd) = GetPerByteState(addr)
  seg = GetCurrentSegment(tid)
  if (is_write): # handle Write event
    SSrd = UpdateSegmentSet(SSrd, {}, seg)
    SSwr = UpdateSegmentSet(SSwr, seg, seg)
  else: # handle Read event
    SSrd = UpdateSegmentSet(SSrd, seg, seg)
  SetPerByteState(SSwr, SSrd)
  if (IsRace(SSwr, SSrd)): 
    ReportRace(is_write, tid, seg, addr)
}}}

{{{
def UpdateSegmentSet(seg_set, init, seg):
  new_seg_set = init
  foreach s in seg_set: 
    if (not (s <= seg)): 
       new_seg_set = union(new_seg_set, s)
  return new_seg_set
}}}

{{{
def IsRace(SSwr, SSrd): 
  for i = 1 .. SSwr.size(): 
    W1 = SSwr[i]
    LS1 = W1.LockSet()
    for j = i + 1 .. SSwr.size(): 
      W2 = SSwr[j]
      LS2 = W2.LockSet()
      Assert(not (W1 <= W2) and not (W2 <= W1))
      if (IntersectionIsEmpty(LS1, LS2)): 
        return True
    foreach R in SSrd: 
      LS3 = R.LockSet()
      if (not (W1 <= R) and IntersectionIsEmpty(LS1, LS3)):
        return True
  return false
}}}

=Reporting races=

TODO

=Pure happens-before mode= 
If we treat the following event pairs as happens-before arcs (in addition to `Signal`/`Wait` pairs), we will get a pure happens-before detector: 
  * `Wrunlock(T1,A)` and `Wrlock(T2,A)`
  * `Rdunlock(T1,A)` and `Wrlock(T2,A)`
  * `Wrunlock(T1,A)` and `Rdlock(T2,A)`

=Fast mode=
ThreadSanitizer (similarly to Helgrind) groups memory locations in *cache lines*. <BR>
The primary purpose of cache lines is to implent fast `GetPerByteState()` function. <BR>

Another use of cache lines is the *fast mode*.

{{{
def HandleMemoryAccessInFastMode(is_write, tid, addr): 
  cache_line = GetCacheLine(addr)
  if (cache_line.WasNeverUsedBefore()):
    # We see this cache line for the first time.
    cache_line.creator_tid = tid:
    return
  if (cache_line.creator_tid == tid):
    # We are still in the same tid.
    return
  cache_line.creator_tid = INVALID_TID
  HandleReadOrWriteEvent(is_write, tid, addr)
}}}

The fast mode helps to avoid some false positives of the hybrid scheme.
This mode is a bit similar to the initialization state in Eraser (TODO: link). 