#summary Memory state machine in the Helgrind development branch, may become a part of Valgrind 3.4.0


*This PAGE is mostly OUTDATED*

= Human redable description = 

A *shadow-word* for each memory location is in one of these states: 
  * *New* -- the memory has been allocated and never accessed since that. When memory is freed it returns to this state.
  * *RdO* (Read only) -- the memory has been read by one or more threads.
  * *Mod* (Modified) -- the memory has been accessed by one or more threads and at least one access was a write.

When a shadow-word is in Mod or RdO state it contains a *segment set* and a *lock set*.

Each memory access updates the state according to the following rules: 

If the shadow word is in state *New*, the state becomes either *Mod* (if the access is a write) or *RdO* (otherwise).
The segment set is set to a singleton segment containing the current segment of the accessing thread.
The lock set is set to the current lock set of the accessing thred (RW-lockset if the access is a write, R-lockset otherwise).

For *Mod* and *RdO* states, if the current segment of the accessing thread happens-after all segments in the shadow word's segment set, 
the state is changed in the same way as if it was *New* before the access. 

Otherwise: 
  * The current segment is inserted into the shadow word's segment set.
  * All segments that happen-before the current segment are removed from the segment set.
  * The lock set becomes the intersection of the previous shadow word's lock set and the current thread's lock set.
  * If the access is a Write, the state is changed to *Mod*.


The race is reported when the following three statements are true: 
  * The state is *Mod*
  * The segment set contains at least two segments.
  * The lock set is empty.

=Formal digram=
For legend see  MemoryStateMachines. 

http://data-race-test.googlecode.com/svn/trunk/msm/helgrind340.png

|| *Edge* || *Old state* || *Access type*     ||  *Condition*     || *New state* || *Segment set*     || *Lock set*      || *Race if ...* ||
|| E1     || New         || read              ||  -               || RdO         || {currS}           || {currLS}        || - ||
|| E2     || New         || write             ||  -               || Mod         || {currS}           || {currLS}        || - ||
|| E3     || RdO         || read              ||  -               || RdO         || *SS_update*       || *LS_update*     || - ||
|| E4     || RdO         || write             ||  -               || Mod         || *SS_update*       || *LS_update*     || #LS==0 && #SS > 1 ||
|| E5     || Mod         || read              || *HB(SS, currS)*  || RdO         || {currS}           || {currLS}        || -      ||
|| E6 (r) || Mod         || read              || *!HB(SS, currS)* || Mod         || *SS_update*       || *LS_update*     || #LS==0 && #SS > 1 ||
|| E6 (w) || Mod         || write             ||  -               || Mod         || *SS_update*       || *LS_update*     || #LS==0 && #SS > 1 ||
 


*SS_update*:
{{{
  def SS_update:
    newSS = {currS}
    for S in oldSS: 
      if(!HB(S,currS)): 
        newSS.insert(S)
    SS = newSS
}}}

*LS_update*:
{{{
  def LS_update: 
    if(HB(oldSS, currS)): 
      newLS = currLS
    else:
      newLS = intersect(LS, currLS)
    LS = newLS
}}}


=Comments=

Compared to [MSMHelgrind MSMHelgrind 3.3.0] this state machine fixes at least these tests: 
  * False negative *test10*. 
  * False positives *test11*, *test12*, *test13*, *test14*, *test16*, *test17*, *test32*, *test39*, *test40*, *test44*.
This state machine still has several false positives (*test28, test29, test36, test38, test46*).
See tests in RacecheckUnittest. 

Tests *test16, test17, test39* pass with this machine only with BarrierSupport.  

*Implementation*: the segments and segment sets can be replaced with just vector time stamp (will try this soon). This may imrove performance, but I find segments and segment sets simpler to understand. 